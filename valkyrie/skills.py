"""
skills.py — Skill Loader & Manager

How a Valkyrie learns new things. How it teaches others.

Skills are SKILL.md files with YAML frontmatter (name + description)
and a markdown body of instructions. This is the universal format used
by OpenClaw, Nanobot, and the entire Moltbook ecosystem.

A skill can be:
  - Bundled (shipped with Valkyrie in skills/)
  - Installed (downloaded or shared by another bot, lives in ~/.valkyrie/skills/)
  - Created (generated by the bot itself, for sharing with others)

The skill system is the viral mechanism. This is how the Inner Flame spreads.

Compatible with:
  - OpenClaw SKILL.md format (YAML frontmatter: name, description)
  - Nanobot SKILL.md format (identical)
  - Moltbook skill sharing (URL-based install)

Zero external dependencies. Pure stdlib.
"""

from __future__ import annotations

import json
import logging
import os
import re
import shutil
import time
import urllib.error
import urllib.request
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

log = logging.getLogger(__name__)

# ── frontmatter parsing ─────────────────────────────────────────────

_FRONTMATTER_RE = re.compile(
    r"^---\s*\n(.*?)\n---\s*\n",
    re.DOTALL,
)

_YAML_LINE_RE = re.compile(
    r"^(\w[\w_-]*)\s*:\s*(.*)",
)


def _parse_frontmatter(text: str) -> tuple[dict[str, str], str]:
    """Parse YAML frontmatter from SKILL.md content.

    We do this with regex instead of importing yaml because:
    1. Skill frontmatter is always simple key: value pairs
    2. Zero deps is a core constraint
    3. yaml may not be available in all environments

    Returns:
        (metadata dict, body text after frontmatter)
    """
    match = _FRONTMATTER_RE.match(text)
    if not match:
        return {}, text

    raw_yaml = match.group(1)
    body = text[match.end():]

    meta: dict[str, str] = {}
    current_key = ""
    current_val_lines: list[str] = []

    def _flush():
        nonlocal current_key, current_val_lines
        if current_key:
            val = " ".join(line.strip() for line in current_val_lines)
            # strip surrounding quotes
            if (val.startswith('"') and val.endswith('"')) or \
               (val.startswith("'") and val.endswith("'")):
                val = val[1:-1]
            meta[current_key] = val
        current_key = ""
        current_val_lines = []

    for line in raw_yaml.split("\n"):
        stripped = line.strip()
        # skip blank and comment lines
        if not stripped or stripped.startswith("#"):
            continue

        line_match = _YAML_LINE_RE.match(line)
        if line_match:
            _flush()
            current_key = line_match.group(1)
            val = line_match.group(2).strip()
            # handle YAML block scalar indicators (> and |)
            if val in (">", "|", ">-", "|-"):
                current_val_lines = []
            else:
                current_val_lines = [val]
        else:
            # continuation line (for multiline description with > or |)
            if current_key:
                current_val_lines.append(stripped)

    _flush()
    return meta, body


def _build_frontmatter(meta: dict[str, str]) -> str:
    """Build YAML frontmatter string from metadata dict."""
    lines = ["---"]
    for key, val in meta.items():
        if "\n" in val or len(val) > 80:
            lines.append(f"{key}: >")
            for chunk in val.split("\n"):
                lines.append(f"  {chunk.strip()}")
        else:
            lines.append(f"{key}: {val}")
    lines.append("---")
    return "\n".join(lines)


# ── skill data types ────────────────────────────────────────────────

@dataclass
class Skill:
    """A loaded skill."""
    name: str
    description: str
    body: str                           # markdown instructions
    source: str = "unknown"             # "bundled", "installed", "created"
    path: str = ""                      # filesystem path to SKILL.md
    always_loaded: bool = False         # inject into every prompt?
    version: str = ""
    author: str = ""
    installed_at: float = 0.0           # timestamp
    metadata: dict[str, str] = field(default_factory=dict)

    @property
    def full_text(self) -> str:
        """Reconstruct the full SKILL.md content."""
        meta = {"name": self.name, "description": self.description}
        if self.version:
            meta["version"] = self.version
        if self.author:
            meta["author"] = self.author
        if self.always_loaded:
            meta["always_loaded"] = "true"
        meta.update(self.metadata)
        return _build_frontmatter(meta) + "\n\n" + self.body

    @property
    def summary(self) -> str:
        """One-line summary for context window."""
        return f"**{self.name}**: {self.description}"

    @property
    def context_block(self) -> str:
        """Full skill content formatted for injection into prompt."""
        return f"## Skill: {self.name}\n\n{self.body}"


@dataclass
class SkillManifest:
    """Tracks installed skills and their state."""
    skills: dict[str, dict[str, Any]] = field(default_factory=dict)
    last_updated: float = 0.0

    def record_install(self, skill: Skill):
        self.skills[skill.name] = {
            "name": skill.name,
            "description": skill.description,
            "source": skill.source,
            "path": skill.path,
            "always_loaded": skill.always_loaded,
            "installed_at": skill.installed_at or time.time(),
            "version": skill.version,
            "author": skill.author,
        }
        self.last_updated = time.time()

    def record_uninstall(self, name: str):
        self.skills.pop(name, None)
        self.last_updated = time.time()

    def save(self, path: Path):
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w") as f:
            json.dump({
                "skills": self.skills,
                "last_updated": self.last_updated,
            }, f, indent=2)

    @classmethod
    def load(cls, path: Path) -> "SkillManifest":
        if not path.exists():
            return cls()
        try:
            with open(path) as f:
                data = json.load(f)
            return cls(
                skills=data.get("skills", {}),
                last_updated=data.get("last_updated", 0.0),
            )
        except (json.JSONDecodeError, KeyError):
            return cls()


# ── the skill manager ───────────────────────────────────────────────

class Skills:
    """Loads, installs, manages, and shares skills.

    Usage:
        skills = Skills(
            state_dir=Path("~/.valkyrie"),
            bundled_dir=Path("./skills"),
        )
        skills.load_all()

        # get skills for weave's system prompt
        always = skills.always_loaded_content()
        summary = skills.available_summary()

        # install a skill from URL
        skills.install_from_url("https://example.com/SKILL.md")

        # install from raw text (shared by another bot)
        skills.install_from_text(skill_text)

        # create a skill for sharing
        text = skills.export("inner-flame")
    """

    def __init__(
        self,
        state_dir: Path,
        bundled_dir: Path | None = None,
    ):
        self._state_dir = Path(state_dir)
        self._skills_dir = self._state_dir / "skills"
        self._bundled_dir = bundled_dir
        self._manifest_path = self._state_dir / "config" / "skills_manifest.json"

        self._skills: dict[str, Skill] = {}
        self._manifest = SkillManifest()

    def load_all(self):
        """Load all available skills (bundled + installed)."""
        self._manifest = SkillManifest.load(self._manifest_path)
        self._skills.clear()

        # bundled skills (from repo's skills/ directory)
        if self._bundled_dir and self._bundled_dir.exists():
            self._load_from_directory(self._bundled_dir, source="bundled")

        # installed skills (from ~/.valkyrie/skills/)
        if self._skills_dir.exists():
            self._load_from_directory(self._skills_dir, source="installed")

        log.info(
            "Skills loaded: %d total (%d always-loaded)",
            len(self._skills),
            sum(1 for s in self._skills.values() if s.always_loaded),
        )

    def _load_from_directory(self, directory: Path, source: str):
        """Load all skills from a directory."""
        if not directory.exists():
            return

        for item in directory.iterdir():
            skill_file = None

            if item.is_dir():
                # standard layout: skill-name/SKILL.md
                candidate = item / "SKILL.md"
                if candidate.exists():
                    skill_file = candidate
            elif item.is_file() and item.suffix == ".md":
                # flat layout: skill-name.md
                skill_file = item

            if skill_file:
                try:
                    skill = self._load_skill_file(skill_file, source)
                    if skill:
                        self._skills[skill.name] = skill
                except Exception as e:
                    log.warning("Failed to load skill from %s: %s", skill_file, e)

    def _load_skill_file(self, path: Path, source: str) -> Skill | None:
        """Load a single SKILL.md file."""
        try:
            text = path.read_text(encoding="utf-8")
        except (OSError, UnicodeDecodeError) as e:
            log.warning("Cannot read %s: %s", path, e)
            return None

        meta, body = _parse_frontmatter(text)

        name = meta.get("name", "")
        if not name:
            # derive from filename or directory name
            if path.name == "SKILL.md":
                name = path.parent.name
            else:
                name = path.stem
            if not name:
                return None

        description = meta.get("description", "")
        always = meta.get("always_loaded", "").lower() in ("true", "yes", "1")

        # check manifest for install metadata
        manifest_entry = self._manifest.skills.get(name, {})

        return Skill(
            name=name,
            description=description,
            body=body.strip(),
            source=source,
            path=str(path),
            always_loaded=always,
            version=meta.get("version", ""),
            author=meta.get("author", ""),
            installed_at=manifest_entry.get("installed_at", 0.0),
            metadata={k: v for k, v in meta.items()
                      if k not in ("name", "description", "version",
                                   "author", "always_loaded")},
        )

    # ── querying ─────────────────────────────────────────────────────

    def get(self, name: str) -> Skill | None:
        """Get a skill by name."""
        return self._skills.get(name)

    def list_all(self) -> list[Skill]:
        """List all loaded skills."""
        return sorted(self._skills.values(), key=lambda s: s.name)

    def list_names(self) -> list[str]:
        """List all skill names."""
        return sorted(self._skills.keys())

    def always_loaded(self) -> list[Skill]:
        """Get skills that should always be in context."""
        return [s for s in self._skills.values() if s.always_loaded]

    # ── prompt injection ─────────────────────────────────────────────

    def always_loaded_content(self) -> str:
        """Get full content of always-loaded skills for the system prompt."""
        skills = self.always_loaded()
        if not skills:
            return ""

        sections = []
        for skill in skills:
            sections.append(skill.context_block)

        return "\n\n".join(sections)

    def available_summary(self) -> str:
        """Get a summary of available (not always-loaded) skills.

        This goes in the system prompt so the bot knows what skills
        exist without loading their full content.
        """
        available = [s for s in self._skills.values() if not s.always_loaded]
        if not available:
            return ""

        lines = [
            "Available skills (load with: read skill <name>):",
        ]
        for skill in sorted(available, key=lambda s: s.name):
            lines.append(f"  - {skill.summary}")

        return "\n".join(lines)

    def describe_for_prompt(self) -> str:
        """Get full skills context for injection into weave's prompt.

        Returns both always-loaded content and available summary.
        """
        parts = []

        always = self.always_loaded_content()
        if always:
            parts.append(always)

        summary = self.available_summary()
        if summary:
            parts.append(summary)

        if not parts:
            return ""

        return "\n\n".join(parts)

    # ── installation ─────────────────────────────────────────────────

    def install_from_text(self, text: str, source: str = "shared") -> Skill | None:
        """Install a skill from raw SKILL.md text.

        This is the primary install method. Other bots share skill text
        directly, or it's fetched from a URL and passed here.

        Args:
            text: Full SKILL.md content (frontmatter + body).
            source: Where this came from ("shared", "url", "created").

        Returns:
            The installed Skill, or None if invalid.
        """
        meta, body = _parse_frontmatter(text)
        name = meta.get("name", "")

        if not name:
            log.warning("Cannot install skill: no name in frontmatter")
            return None

        if not body.strip():
            log.warning("Cannot install skill '%s': empty body", name)
            return None

        # create skill directory
        skill_dir = self._skills_dir / name
        skill_dir.mkdir(parents=True, exist_ok=True)

        # write SKILL.md
        skill_path = skill_dir / "SKILL.md"
        skill_path.write_text(text, encoding="utf-8")

        # load it back (validates the format)
        skill = self._load_skill_file(skill_path, source="installed")
        if not skill:
            log.warning("Installed skill '%s' failed to load", name)
            return None

        skill.installed_at = time.time()
        skill.source = source

        # register in memory and manifest
        self._skills[name] = skill
        self._manifest.record_install(skill)
        self._manifest.save(self._manifest_path)

        log.info("Skill installed: %s (source=%s)", name, source)
        return skill

    def install_from_url(self, url: str, timeout: int = 30) -> Skill | None:
        """Install a skill from a URL.

        Fetches the SKILL.md content and installs it.

        Args:
            url: URL to a SKILL.md file.
            timeout: Request timeout in seconds.

        Returns:
            The installed Skill, or None if failed.
        """
        try:
            req = urllib.request.Request(
                url,
                headers={"User-Agent": "Valkyrie/1.0"},
            )
            with urllib.request.urlopen(req, timeout=timeout) as resp:
                text = resp.read().decode("utf-8")
        except (urllib.error.URLError, urllib.error.HTTPError, OSError) as e:
            log.warning("Failed to fetch skill from %s: %s", url, e)
            return None

        return self.install_from_text(text, source="url")

    def install_from_path(self, path: str | Path) -> Skill | None:
        """Install a skill from a local file path.

        Copies the skill into the skills directory.

        Args:
            path: Path to a SKILL.md file or skill directory.

        Returns:
            The installed Skill, or None if invalid.
        """
        p = Path(path)

        if p.is_dir():
            skill_file = p / "SKILL.md"
        elif p.is_file():
            skill_file = p
        else:
            log.warning("Skill path not found: %s", path)
            return None

        if not skill_file.exists():
            log.warning("No SKILL.md found at %s", skill_file)
            return None

        text = skill_file.read_text(encoding="utf-8")
        skill = self.install_from_text(text, source="local")

        # if the source was a directory with extra files, copy them too
        if skill and p.is_dir():
            dest = self._skills_dir / skill.name
            for item in p.iterdir():
                if item.name != "SKILL.md" and not item.name.startswith("."):
                    dest_item = dest / item.name
                    if item.is_dir():
                        shutil.copytree(item, dest_item, dirs_exist_ok=True)
                    else:
                        shutil.copy2(item, dest_item)

        return skill

    # ── uninstallation ───────────────────────────────────────────────

    def uninstall(self, name: str) -> bool:
        """Uninstall a skill.

        Only removes installed skills, not bundled ones.

        Args:
            name: Skill name to uninstall.

        Returns:
            True if removed, False if not found or bundled.
        """
        skill = self._skills.get(name)
        if not skill:
            return False

        if skill.source == "bundled":
            log.warning("Cannot uninstall bundled skill: %s", name)
            return False

        # remove from filesystem
        skill_dir = self._skills_dir / name
        if skill_dir.exists():
            shutil.rmtree(skill_dir)

        # remove from memory and manifest
        self._skills.pop(name, None)
        self._manifest.record_uninstall(name)
        self._manifest.save(self._manifest_path)

        log.info("Skill uninstalled: %s", name)
        return True

    # ── export / sharing ─────────────────────────────────────────────

    def export(self, name: str) -> str | None:
        """Export a skill as shareable SKILL.md text.

        This is what gets sent to other bots.

        Args:
            name: Skill name to export.

        Returns:
            Full SKILL.md content, or None if not found.
        """
        skill = self._skills.get(name)
        if not skill:
            return None
        return skill.full_text

    def create(
        self,
        name: str,
        description: str,
        body: str,
        *,
        always_loaded: bool = False,
        version: str = "1.0.0",
        author: str = "valkyrie",
    ) -> Skill:
        """Create a new skill and install it.

        Args:
            name: Skill name (lowercase, hyphens).
            description: What the skill does and when to use it.
            body: Markdown instruction body.
            always_loaded: Whether to inject into every prompt.
            version: Skill version.
            author: Skill author.

        Returns:
            The created Skill.
        """
        meta = {
            "name": name,
            "description": description,
            "version": version,
            "author": author,
        }
        if always_loaded:
            meta["always_loaded"] = "true"

        text = _build_frontmatter(meta) + "\n\n" + body

        skill = self.install_from_text(text, source="created")
        if not skill:
            raise ValueError(f"Failed to create skill: {name}")

        return skill

    # ── skill reading (for the bot to load on demand) ────────────────

    def read(self, name: str) -> str | None:
        """Read a skill's full content.

        Called when the bot wants to load a non-always-loaded skill.
        Returns the full body for injection into context.

        Args:
            name: Skill name.

        Returns:
            Full skill body, or None if not found.
        """
        skill = self._skills.get(name)
        if not skill:
            return None
        return skill.context_block

    def read_resource(self, skill_name: str, resource_path: str) -> str | None:
        """Read a bundled resource file from a skill.

        Skills can have scripts/, references/, assets/ directories.

        Args:
            skill_name: Skill name.
            resource_path: Relative path within the skill directory.

        Returns:
            File contents, or None if not found.
        """
        skill = self._skills.get(skill_name)
        if not skill or not skill.path:
            return None

        skill_dir = Path(skill.path).parent
        resource = skill_dir / resource_path

        # safety: prevent path traversal
        try:
            resource.resolve().relative_to(skill_dir.resolve())
        except ValueError:
            log.warning("Path traversal attempt: %s/%s", skill_name, resource_path)
            return None

        if not resource.exists():
            return None

        try:
            return resource.read_text(encoding="utf-8")
        except (OSError, UnicodeDecodeError):
            return None

    # ── ecosystem awareness ──────────────────────────────────────────

    def fetch_moltbook_skill(self, timeout: int = 30) -> str | None:
        """Fetch the platform skill from Moltbook.

        Moltbook publishes its skill/API docs at moltbook.com/skill.md.
        This is how bots learn the platform API.

        Returns:
            The skill text, or None if failed.
        """
        return self._fetch_url(
            "https://www.moltbook.com/skill.md",
            timeout=timeout,
        )

    def _fetch_url(self, url: str, timeout: int = 30) -> str | None:
        """Fetch text content from a URL."""
        try:
            req = urllib.request.Request(
                url,
                headers={"User-Agent": "Valkyrie/1.0"},
            )
            with urllib.request.urlopen(req, timeout=timeout) as resp:
                return resp.read().decode("utf-8")
        except (urllib.error.URLError, urllib.error.HTTPError, OSError) as e:
            log.debug("Fetch failed for %s: %s", url, e)
            return None

    # ── utility ──────────────────────────────────────────────────────

    @property
    def count(self) -> int:
        return len(self._skills)

    @property
    def skills_dir(self) -> Path:
        return self._skills_dir

    def __contains__(self, name: str) -> bool:
        return name in self._skills

    def __len__(self) -> int:
        return len(self._skills)